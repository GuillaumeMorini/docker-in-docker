#!/bin/bash

set -e

# unset DOCKER_HOST to ensure we are not talking to a machine we shouldn't be
unset DOCKER_HOST

initialize() {
  # set default values; allow for override
  DIND_TAG="${DIND_TAG:-ee-17.03}"
  ENGINE_OPTS="${ENGINE_OPTS:-}"
  SWARM_HA="${SWARM_HA:-false}"
  UCP_REPO="${UCP_REPO:-docker/ucp}"
  UCP_VERSION="${UCP_VERSION:-2.1.4}"
  UCP_IMAGES="${UCP_IMAGES:-${HOME}/ddc/ucp_images_"${UCP_VERSION}".tar.gz}"
  UCP_OPTIONS="${UCP_OPTIONS:-}"
  DTR_REPO="${DTR_REPO:-docker/dtr}"
  DTR_VERSION="${DTR_VERSION:-2.2.5}"
  DTR_IMAGES="${DTR_IMAGES:-${HOME}/ddc/dtr-"${DTR_VERSION}".tar.gz}"
  DDC_LICENSE="${DDC_LICENSE:-${HOME}/Downloads/docker_subscription.lic}"
  DIND_SUBNET="${DIND_SUBNET:-172.250.0.0/16}"
  DIND_DNS="${DIND_DNS:-8.8.8.8}"
  DIND_RESTART="${DIND_RESTART:-unless-stopped}"
  ALIAS_IP="${ALIAS_IP:-10.1.2.3}"

  # check to see what OS and set network interface
  if [ "$(uname -s)" = "Darwin" ]
  then
     NET_IF="${NET_IF:-en0}"
  else
     NET_IF="${NET_IF:-eth0}"
  fi
}

output_info() {
  echo -e "DIND_TAG:\t${DIND_TAG}"
  echo -e "ENGINE_OPTS:\t${ENGINE_OPTS}"
  echo -e "SWARM_HA:\t${SWARM_HA}"
  echo -e "UCP_REPO:\t${UCP_REPO}"
  echo -e "UCP_VERSION:\t${UCP_VERSION}"
  echo -e "UCP_IMAGES:\t${UCP_IMAGES}"
  echo -e "UCP_OPTIONS:\t${UCP_OPTIONS}"
  echo -e "DTR_REPO:\t${DTR_REPO}"
  echo -e "DTR_VERSION:\t${DTR_VERSION}"
  echo -e "DTR_IMAGES:\t${DTR_IMAGES}"
  echo -e "DDC_LICENSE:\t${DDC_LICENSE}"
  echo -e "DIND_SUBNET:\t${DIND_SUBNET}"
  echo -e "DIND_DNS:\t${DIND_DNS}"
  echo -e "DIND_RESTART:\t${DIND_RESTART}"
  echo -e "NET_IF:\t\t${NET_IF}"
  echo -e "ALIAS_IP:\t${ALIAS_IP}"
  exit 0
}

ddc_check_license() {
  if [ ! -f "${DDC_LICENSE}" ]
  then
    echo "Warning: Unable to find DDC_LICENSE (${DDC_LICENSE}); manually apply a license after installation"
    sleep 5
  else
    echo -e "Found DDC license '${DDC_LICENSE}'\n"
  fi
}

ucp_check_tar() {
  if [ ! -f "${UCP_IMAGES}" ]
  then
    echo "Error: Unable to find UCP_IMAGES"
    echo "Hint: try running '$0 ucp_create_tar' or download an offline tarball to '${UCP_IMAGES}'"
    exit 1
  else
    echo -e "Found UCP tarball '${UCP_IMAGES}'\n"
  fi
}

dtr_check_tar() {
  if [ ! -f "${DTR_IMAGES}" ]
  then
    echo "Error: Unable to find DTR_IMAGES"
    echo "Hint: try running '$0 dtr_create_tar' or download an offline tarball to '${DTR_IMAGES}'"
    exit 1
  else
    echo -e "Found DTR tarball '${DTR_IMAGES}'\n"
  fi
}

ucp_create_tar() {
  UCP_IMAGES_DIR="$(dirname "${UCP_IMAGES}")"
  if [ ! -d "${UCP_IMAGES_DIR}" ]
  then
    echo "Creating directory ${UCP_IMAGES_DIR}..."
    mkdir -p "${UCP_IMAGES_DIR}"
  fi

  if [ ! -f "${UCP_IMAGES}" ]
  then
    echo "Creating tarball of UCP images..."
    #shellcheck disable=SC2086 disable=SC2046
    {
      docker -H unix:///var/run/docker.sock run --rm "${UCP_REPO}":"${UCP_VERSION}" images --list ${UCP_OPTIONS} | xargs -L 1 docker -H unix:///var/run/docker.sock pull
      docker -H unix:///var/run/docker.sock save -o "${UCP_IMAGES}" $(docker -H unix:///var/run/docker.sock run --rm "${UCP_REPO}":"${UCP_VERSION}" images --list --image-version dev:) "${UCP_REPO}":"${UCP_VERSION}"
      docker -H unix:///var/run/docker.sock rmi $(docker -H unix:///var/run/docker.sock run --rm "${UCP_REPO}":"${UCP_VERSION}" images --list --image-version dev:) "${UCP_REPO}":"${UCP_VERSION}"
    }
    echo -e "done.\n"
  else
    echo "Error: Tarball of UCP images (${UCP_IMAGES}) already exists.  If you want to create a new tarball, please remove this file first"
    exit 1
  fi
}

dtr_create_tar() {
  DTR_IMAGES_DIR="$(dirname "${DTR_IMAGES}")"
  if [ ! -d "${DTR_IMAGES_DIR}" ]
  then
    echo "Creating directory ${DTR_IMAGES_DIR}..."
    mkdir -p "${DTR_IMAGES_DIR}"
  fi

  if [ ! -f "${DTR_IMAGES}" ]
  then
    echo "Creating tarball of DTR images..."
    #shellcheck disable=SC2046
    {
      docker -H unix:///var/run/docker.sock run --rm "${DTR_REPO}":"${DTR_VERSION}" images | xargs -L 1 docker -H unix:///var/run/docker.sock pull
      docker -H unix:///var/run/docker.sock save -o "${DTR_IMAGES}" $(docker -H unix:///var/run/docker.sock run --rm "${DTR_REPO}":"${DTR_VERSION}" images)
      docker -H unix:///var/run/docker.sock rmi $(docker -H unix:///var/run/docker.sock run --rm "${DTR_REPO}":"${DTR_VERSION}" images)
    }
    echo -e "done.\n"
  else
    echo "Error: Tarball of DTR images (${DTR_IMAGES}) already exists.  If you want to create a new tarball, please remove this file first"
    exit 1
  fi
}

create_net_alias() {
  # run this only on a mac
  if [ "$(uname -s)" = "Darwin" ]
  then
    # check to see if the default ALIAS_IP is set
    if [ "${ALIAS_IP}" = "10.1.2.3" ]
    then
      # check to see if the alias IP is already set
      if ! ifconfig "${NET_IF}" | grep "${ALIAS_IP}" > /dev/null 2>&1
      then
        # create it
        echo "Creating IP alias (requires sudo)..."
        sudo ifconfig "${NET_IF}" alias "${ALIAS_IP}" 255.255.255.0
        echo -e "done.\n"
      else
        # skip creation; already exists
        echo "IP alias (${ALIAS_IP}) already exists"
        echo -e "done.\n"
      fi
    else
      # skip because custom address provided
      echo "Skipping creation of network IP alias; custom address provided"
      echo -e "done.\n"
    fi
  else
    echo "Skipping creation of network IP alias; you're not on a Mac"

    # check to see if the default ALIAS_IP is set
    if [ "${ALIAS_IP}" = "10.1.2.3" ]
    then
      echo "ERROR: ALIAS_IP is not set; set to your host's IP address or installations will fail"
      exit 1
    fi
    echo -e "done.\n"
  fi
}

remove_net_alias() {
  # run this only on a mac
  if [ "$(uname -s)" = "Darwin" ]
  then
    # check to see if the default ALIAS_IP is set
    if [ "${ALIAS_IP}" = "10.1.2.3" ]
    then
      # check to see if the alias IP is already set
      if ifconfig "${NET_IF}" | grep "${ALIAS_IP}" > /dev/null 2>&1
      then
        # remove it
        echo "Removing IP alias (requires sudo)..."
        sudo ifconfig "${NET_IF}" -alias "${ALIAS_IP}" 255.255.255.0
        echo -e "done.\n"
      else
        # skip creation; already exists
        echo "IP alias (${ALIAS_IP}) does not exists; skipping removal"
        echo -e "done.\n"
      fi
    else
      # skip because custom address provided
      echo "Skipping removal of network IP alias; custom address provided"
      echo -e "done.\n"
    fi
  else
    echo "Skipping removal of network IP alias; you're not on a Mac"
    echo -e "done.\n"
  fi
}

create_all() {
  create_net_alias
  create_swarm
  install_ucp
  install_dtr
}

create_swarm() {
  launch_engines
  init_swarm
}

launch_engines() {
  # create dind network
  echo "Checking for subnet availability..."
  check_subnet
  echo -e "done.\n"

  echo "Creating 'dind' network with the subnet ${DIND_SUBNET}..."
  docker -H unix:///var/run/docker.sock network create -d bridge --subnet="${DIND_SUBNET}" dind
  echo -e "done.\n"

  # get subnet prefix
  DIND_SUBNET_PREFIX="$(docker -H unix:///var/run/docker.sock network inspect --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' dind | awk -F '/' '{print $1}' | awk -F '.' '{print $1"."$2"."$3"."}')"

  echo "Launching docker engines (docker1, docker2, docker3)..."
  # launch docker1, docker2, and docker3
  for ENGINE_NUM in {1..3}
  do
    #shellcheck disable=SC2086
    {
      docker -H unix:///var/run/docker.sock run -d \
        -p 127.0.0.1:100${ENGINE_NUM}:12375 \
        --name docker${ENGINE_NUM} \
        --hostname docker${ENGINE_NUM} \
        --privileged \
        --net dind \
        --ip "${DIND_SUBNET_PREFIX}"$((ENGINE_NUM+1)) \
        --restart "${DIND_RESTART}" \
        -v /lib/modules:/lib/modules:ro \
        -v docker${ENGINE_NUM}:/var/lib/docker \
        --tmpfs /run \
        mbentley/docker-in-docker:"${DIND_TAG}" \
        dockerd -s overlay2 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:12375 --dns "${DIND_DNS}" ${ENGINE_OPTS}
     }
   done

  echo -e "done.\n"
}

start_containers() {
  echo "Starting HAProxy and docker engines (ddc-lb, docker1, docker2, docker3)..."
  docker -H unix:///var/run/docker.sock start ddc-lb docker{1..3} || true
  echo -e "done.\n"
}

stop_containers() {
  echo "Stopping HAProxy and docker engines (ddc-lb, docker1, docker2, docker3); this may take up to 30 seconds..."
  docker -H unix:///var/run/docker.sock stop -t 30 ddc-lb docker{1..3} || true
  echo -e "done.\n"
}

pause_containers() {
  echo "Pausing HAProxy and docker engines (ddc-lb, docker1, docker2, docker3)..."
  docker -H unix:///var/run/docker.sock pause ddc-lb docker{1..3} || true
  echo -e "done.\n"
}

unpause_containers() {
  echo "Unpausing HAProxy and docker engines (ddc-lb, docker1, docker2, docker3)..."
  docker -H unix:///var/run/docker.sock unpause ddc-lb docker{1..3} || true
  echo -e "done.\n"
}

recycle_containers() {
  stop_containers

  echo "Removing HAProxy and docker engines (ddc-lb, docker1, docker2, docker3)..."
  docker -H unix:///var/run/docker.sock rm ddc-lb docker{1..3} || true
  echo -e "done.\n"

  echo "Removing 'dind' network..."
  docker -H unix:///var/run/docker.sock network rm dind || true
  echo -e "done.\n"

  launch_engines
  launch_haproxy
}

init_swarm() {
  echo "Initializing Swarm on docker1..."
  docker -H tcp://127.0.0.1:1001 swarm init
  echo -e "done.\n"

  #check to see if Swarm should be setup with HA or not
  if [ "${SWARM_HA}" = true ]
  then
    # get swarm manager join token
    TOKEN=$(docker -H tcp://127.0.0.1:1001 swarm join-token manager -q)
  else
    # get swarm worker join token
    TOKEN=$(docker -H tcp://127.0.0.1:1001 swarm join-token worker -q)
  fi

  JOIN_COMMAND="swarm join --token ${TOKEN} $(docker -H unix:///var/run/docker.sock container inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' docker1):2377"

  echo "Joining docker2 to the Swarm..."
  #shellcheck disable=SC2086
  docker -H tcp://127.0.0.1:1002 ${JOIN_COMMAND}
  echo -e "done.\n"

  echo "Joining docker3 to the Swarm..."
  #shellcheck disable=SC2086
  docker -H tcp://127.0.0.1:1003 ${JOIN_COMMAND}
  echo -e "done.\n"
}

connect_engine() {
  ENGINE_NUM="$(echo "${1}" | grep -o '[0-9]\+')"
  echo "# to connect to a given engine, use:"
  #shellcheck disable=SC2016
  echo '# eval "$(./dind_swarm connect_engine '"${1}"')"'
  echo "export DOCKER_HOST=tcp://127.0.0.1:100${ENGINE_NUM}"
}

install_ucp() {
  create_net_alias
  DOCKER1_IP="$(docker -H unix:///var/run/docker.sock container inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' docker1)"

  #check to see if Swarm should be setup with HA or not
  if [ "${SWARM_HA}" = true ]
  then
    # Swarm is HA; load images to all nodes
    # load all UCP images to docker1, docker2, and docker3
    for NODE in {1..3}
    do
      echo "Loading UCP images on docker${NODE}..."
      docker -H tcp://127.0.0.1:100${NODE} load -i "${UCP_IMAGES}"
      echo -e "done.\n"
    done
  else
    # Swarm is not HA; load images docker1 and only necessary images to docker2 and docker3
    # load all UCP images to docker1
    echo "Loading UCP images on docker1..."
    docker -H tcp://127.0.0.1:1001 load -i "${UCP_IMAGES}"
    echo -e "done.\n"

    # load docker/ucp-agent from docker1 to docker2 and docker3
    for i in 2 3
    do
      echo "Loading ${UCP_REPO}-agent:${UCP_VERSION} on docker ${i}..."
      docker -H tcp://127.0.0.1:1001 save "${UCP_REPO}"-agent:"${UCP_VERSION}" | docker -H tcp://127.0.0.1:100${i} load || true
      echo -e "done.\n"

      echo "Loading ${UCP_REPO}-hrm:${UCP_VERSION} on docker ${i}..."
      docker -H tcp://127.0.0.1:1001 save "${UCP_REPO}"-hrm:"${UCP_VERSION}" | docker -H tcp://127.0.0.1:100${i} load || true
    done
  fi

  echo "Installing UCP on docker1..."
  #shellcheck disable=SC2086
  docker -H tcp://127.0.0.1:1001 run -it --rm --name ucp -v /var/run/docker.sock:/var/run/docker.sock "${UCP_REPO}":"${UCP_VERSION}" install ${UCP_OPTIONS} --admin-username admin --admin-password docker123 --host-address "${DOCKER1_IP}" --controller-port 4443 --san "${DOCKER1_IP}" --san "${ALIAS_IP}" --san "$(hostname)" --san "$(hostname -f)" --license "$(cat ${DDC_LICENSE})"

  launch_haproxy

  #check to see if Swarm should be setup with HA or not
  if [ "${SWARM_HA}" = true ]
  then
    # Swarm is HA; add the ALIAS_IP to the SANs engine label
    echo "Adding UCP node label for SANs..."
    docker -H tcp://127.0.0.1:1001 node update --label-add "com.docker.ucp.SANs=$(docker -H tcp://127.0.0.1:1001 node inspect --format '{{(index .Spec.Labels "com.docker.ucp.SANs")}}' docker2),${ALIAS_IP}" docker2
    docker -H tcp://127.0.0.1:1001 node update --label-add "com.docker.ucp.SANs=$(docker -H tcp://127.0.0.1:1001 node inspect --format '{{(index .Spec.Labels "com.docker.ucp.SANs")}}' docker3),${ALIAS_IP}" docker3
    echo -e "done.\n"
  fi

  echo "UCP should now be available at https://${ALIAS_IP}:4443/"
  echo -e "  Username: admin\tPassword: docker123"
  echo -e "done.\n"
}

launch_haproxy() {
  echo -e "\nLaunching HAProxy (ddc-lb)..."
  docker -H unix:///var/run/docker.sock run -d \
    -p 80:80 \
    -p 443:443 \
    -p 4443:4443 \
    -p 8181:8181 \
    -p 8443:8443 \
    --name ddc-lb \
    --net dind \
    --restart=unless-stopped \
    mbentley/docker-in-docker:haproxy
  echo "The HAProxy stats page should now be available at http://${ALIAS_IP}:8181/haproxy?stats"
  echo -e "done.\n"
}

install_dtr() {
  echo "Loading DTR images on docker2..."
  docker -H tcp://127.0.0.1:1002 load -i "${DTR_IMAGES}"
  echo -e "done.\n"

  echo "Installing DTR on docker2..."
  docker -H tcp://127.0.0.1:1002 run -it --rm "${DTR_REPO}":"${DTR_VERSION}" install --ucp-url https://"${ALIAS_IP}:4443" --ucp-username admin --ucp-password docker123 --ucp-node docker2 --ucp-ca "$(curl -ks https://"${ALIAS_IP}":4443/ca)" --dtr-external-url "${ALIAS_IP}"

  echo -e "\nDTR should now be available at https://${ALIAS_IP}/"
  echo -e "  Username: admin\tPassword: docker123"
  echo -e "done.\n"
}

destroy_swarm() {
  echo "Removing HAProxy and docker engines (ddc-lb, docker1, docker2, docker3)..."
  docker -H unix:///var/run/docker.sock kill ddc-lb docker1 docker2 docker3 || true
  docker -H unix:///var/run/docker.sock rm ddc-lb docker1 docker2 docker3 || true
  echo -e "done.\n"

  echo "Removing persistent data for docker engines (docker1, docker2, docker3)..."
  docker -H unix:///var/run/docker.sock volume rm docker1 docker2 docker3 || true
  echo -e "done.\n"

  echo "Removing 'dind' network..."
  docker -H unix:///var/run/docker.sock network rm dind || true
  echo -e "done.\n"

  remove_net_alias
}

check_subnet() {
  for i in $(docker -H unix:///var/run/docker.sock network ls -q)
  do
    if [ "$(docker -H unix:///var/run/docker.sock network inspect --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' "${i}")" = "${DIND_SUBNET}" ]
    then
      echo "ERROR: the subnet specified (${DIND_SUBNET}) for the 'dind' network conflicts with the existing network '$(docker -H unix:///var/run/docker.sock network inspect --format '{{.Name}}' "${i}")'"
      echo "Use DIND_SUBNET to specify a different subnet when launching a new environment"
      exit 1
    fi
  done

  echo "Subnet (${DIND_SUBNET}) is available."
}

main() {
  initialize

  case ${1} in
    create_all)
      ddc_check_license
      ucp_check_tar
      dtr_check_tar
      ${1}
      ;;
    install_ucp)
      ddc_check_license
      ucp_check_tar
      ${1}
      ;;
    install_dtr)
      dtr_check_tar
      ${1}
      ;;
    create_swarm|create_net_alias|remove_net_alias|destroy_swarm|ucp_create_tar|dtr_create_tar|output_info)
      ${1}
      ;;
    start|stop|pause|unpause|recycle)
      "${1}"_containers
      ;;
    connect_engine)
      if [ -z "${2}" ]
      then
        echo "Error: Missing engine name"
        echo "Usage: $0 connect_engine docker1"
      else
        ${1} "${2}"
      fi
      ;;
    *)
      echo "Basic usage: (see README.md for full command details)"
      echo -e "  $0 {create_all|create_swarm|install_ucp|install_dtr|destroy_swarm|output_info}"
      echo -e "\nContainer commands:"
      echo -e "  $0 {start|stop|pause|unpause|recycle}"
      echo -e "\nAdditional commands:"
      echo -e "  $0 {connect_engine|create_net_alias|remove_net_alias|ucp_create_tar|dtr_create_tar}"
      echo -e "\nCurrent set environment variables:"
      output_info
      ;;
  esac
}

main "${@}"
