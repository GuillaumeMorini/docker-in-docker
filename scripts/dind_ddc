#!/bin/bash

set -e

# unset DOCKER_HOST, DOCKER_TLS_VERIFY, and DOCKER_CERT_PATH to ensure we are not talking to a machine we shouldn't be
unset DOCKER_HOST DOCKER_TLS_VERIFY DOCKER_CERT_PATH

initialize() {
  # source an external env var file if DIND_ENV set
  DIND_ENV="${DIND_ENV:-}"
  if ! [ -z "${DIND_ENV}" ]
  then
    # make sure DIND_ENV is a file
    if [ -f "${DIND_ENV}" ]
    then
      echo -e "Using environment variables from '${DIND_ENV}'\n"
      #shellcheck disable=SC1090
      source "${DIND_ENV}"
    else
      echo "Warning: DIND_ENV file not found; unable to load environment variables"
      sleep 3
    fi
  fi

  # set default values; allow for override
  PROJECT="${PROJECT:-dind-ddc}"
  DIND_TAG="${DIND_TAG:-ee-17.06}"
  ENGINE_OPTS="${ENGINE_OPTS:-}"
  MANAGERS="${MANAGERS:-1}"
  WORKERS="${WORKERS:-2}"
  UCP_REPO="${UCP_REPO:-docker/ucp}"
  UCP_VERSION="${UCP_VERSION:-2.2.2}"
  UCP_IMAGES="${UCP_IMAGES:-${HOME}/ddc/ucp_images_"${UCP_VERSION}".tar.gz}"
  UCP_OPTIONS="${UCP_OPTIONS:-}"
  DTR_REPO="${DTR_REPO:-docker/dtr}"
  DTR_VERSION="${DTR_VERSION:-2.3.2}"
  DTR_IMAGES="${DTR_IMAGES:-${HOME}/ddc/dtr-"${DTR_VERSION}".tar.gz}"
  DTR_OPTIONS="${DTR_OPTIONS:-}"
  DTR_REPLICAS="${DTR_REPLICAS:-1}"
  DDC_LICENSE="${DDC_LICENSE:-${HOME}/Downloads/docker_subscription.lic}"
  DIND_SUBNET="${DIND_SUBNET:-172.250.1.0/24}"
  DIND_RESTART="${DIND_RESTART:-unless-stopped}"
  ALIAS_IP="${ALIAS_IP:-10.1.2.3}"
  DOMAIN_NAME="${DOMAIN_NAME:-demo.mac}"
  GH_USERNAME="${GH_USERNAME:-demo}"

  #  only run a container to get resolv.conf from the engine if DIND_DNS wasn't specified
  if [ -z "${DIND_DNS}" ]
  then
    DIND_DNS="$(docker -H unix:///var/run/docker.sock run --rm busybox cat /etc/resolv.conf | grep -m 1 ^nameserver | awk '{print $2}')"

    # lazy check for ip like string
    if ! [[ ${DIND_DNS} =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]
    then
      # if all else fails, set the DNS server to google's primary
      echo "Warning: unable to determine DNS server used by host docker engine; using Google"
      DIND_DNS="8.8.8.8"
    fi
  fi

  # check to see what OS and set network interface
  if [ "$(uname -s)" = "Darwin" ]
  then
     NET_IF="${NET_IF:-en0}"
  else
     NET_IF="${NET_IF:-eth0}"
  fi

  # check for valid number of managers
  if ((MANAGERS<1))
  then
    echo "Error: The number of MANAGERS (${MANAGERS}) must be greater than 0"
    exit 1
  fi

  # check for valid number of workers
  if ((WORKERS<1))
  then
    echo "Warning: The number of WORKERS (${MANAGERS}) is less than 1; you will not be able to install DTR"
    sleep 5
  fi

}

validate_dtr_replicas() {
  # check for valid number of DTR replicas
  if ((DTR_REPLICAS<1))
  then
    echo "Error: The number of DTR_REPLICAS (${DTR_REPLICAS}) is less than 1; you will not be able to install DTR"
    exit 1
  fi

  if ((DTR_REPLICAS>WORKERS))
  then
    echo "Error: The number of DTR_REPLICAS (${DTR_REPLICAS}) is greater then the number of UCP workers (${WORKERS}); you will not be able to install DTR with the specified number of replicas"
    exit 1
  fi
}

env_info() {
  echo -e "DIND_ENV:\t${DIND_ENV}"
  echo -e "PROJECT:\t${PROJECT}"
  echo -e "DIND_TAG:\t${DIND_TAG}"
  echo -e "ENGINE_OPTS:\t${ENGINE_OPTS}"
  echo -e "MANAGERS:\t${MANAGERS}"
  echo -e "WORKERS:\t${WORKERS}"
  echo -e "UCP_REPO:\t${UCP_REPO}"
  echo -e "UCP_VERSION:\t${UCP_VERSION}"
  echo -e "UCP_IMAGES:\t${UCP_IMAGES}"
  echo -e "UCP_OPTIONS:\t${UCP_OPTIONS}"
  echo -e "DTR_REPO:\t${DTR_REPO}"
  echo -e "DTR_VERSION:\t${DTR_VERSION}"
  echo -e "DTR_IMAGES:\t${DTR_IMAGES}"
  echo -e "DDC_LICENSE:\t${DDC_LICENSE}"
  echo -e "DTR_OPTIONS:\t${DTR_OPTIONS}"
  echo -e "DTR_REPLICAS:\t${DTR_REPLICAS}"
  echo -e "DIND_SUBNET:\t${DIND_SUBNET}"
  echo -e "DIND_DNS:\t${DIND_DNS}"
  echo -e "DIND_RESTART:\t${DIND_RESTART}"
  echo -e "NET_IF:\t\t${NET_IF}"
  echo -e "ALIAS_IP:\t${ALIAS_IP}"
  echo -e "DOMAIN_NAME:\t${DOMAIN_NAME}"
  echo -e "GH_USERNAME:\t${GH_USERNAME}"
  exit 0
}

ddc_check_license() {
  if [ ! -f "${DDC_LICENSE}" ]
  then
    echo "Warning: Unable to find DDC_LICENSE (${DDC_LICENSE}); manually apply a license after installation"
    sleep 5
  else
    echo -e "Found DDC license '${DDC_LICENSE}'\n"
  fi
}

ucp_check_tar() {
  if [ ! -f "${UCP_IMAGES}" ]
  then
    echo "Error: Unable to find UCP_IMAGES"
    echo "Hint: try running '$0 ucp_create_tar' or download an offline tarball to '${UCP_IMAGES}'"
    exit 1
  else
    echo -e "Found UCP tarball '${UCP_IMAGES}'\n"
  fi
}

dtr_check_tar() {
  if [ ! -f "${DTR_IMAGES}" ]
  then
    echo "Error: Unable to find DTR_IMAGES"
    echo "Hint: try running '$0 dtr_create_tar' or download an offline tarball to '${DTR_IMAGES}'"
    exit 1
  else
    echo -e "Found DTR tarball '${DTR_IMAGES}'\n"
  fi
}

ucp_create_tar() {
  UCP_IMAGES_DIR="$(dirname "${UCP_IMAGES}")"
  if [ ! -d "${UCP_IMAGES_DIR}" ]
  then
    echo "Creating directory ${UCP_IMAGES_DIR}..."
    mkdir -p "${UCP_IMAGES_DIR}"
  fi

  if [ ! -f "${UCP_IMAGES}" ]
  then
    echo "Creating tarball of UCP images..."
    #shellcheck disable=SC2086 disable=SC2046
    {
      docker -H unix:///var/run/docker.sock run --rm "${UCP_REPO}":"${UCP_VERSION}" images --list ${UCP_OPTIONS} | xargs -L 1 docker -H unix:///var/run/docker.sock pull
      docker -H unix:///var/run/docker.sock save -o "${UCP_IMAGES}" $(docker -H unix:///var/run/docker.sock run --rm "${UCP_REPO}":"${UCP_VERSION}" images --list ${UCP_OPTIONS}) "${UCP_REPO}":"${UCP_VERSION}"
      docker -H unix:///var/run/docker.sock rmi $(docker -H unix:///var/run/docker.sock run --rm "${UCP_REPO}":"${UCP_VERSION}" images --list ${UCP_OPTIONS}) "${UCP_REPO}":"${UCP_VERSION}"
    }
    echo -e "done.\n"
  else
    echo "Error: Tarball of UCP images (${UCP_IMAGES}) already exists.  If you want to create a new tarball, please remove this file first"
    exit 1
  fi
}

dtr_create_tar() {
  DTR_IMAGES_DIR="$(dirname "${DTR_IMAGES}")"
  if [ ! -d "${DTR_IMAGES_DIR}" ]
  then
    echo "Creating directory ${DTR_IMAGES_DIR}..."
    mkdir -p "${DTR_IMAGES_DIR}"
  fi

  if [ ! -f "${DTR_IMAGES}" ]
  then
    echo "Creating tarball of DTR images..."
    #shellcheck disable=SC2046
    {
      docker -H unix:///var/run/docker.sock run --rm "${DTR_REPO}":"${DTR_VERSION}" images | xargs -L 1 docker -H unix:///var/run/docker.sock pull
      docker -H unix:///var/run/docker.sock save -o "${DTR_IMAGES}" $(docker -H unix:///var/run/docker.sock run --rm "${DTR_REPO}":"${DTR_VERSION}" images)
      docker -H unix:///var/run/docker.sock rmi $(docker -H unix:///var/run/docker.sock run --rm "${DTR_REPO}":"${DTR_VERSION}" images)
    }
    echo -e "done.\n"
  else
    echo "Error: Tarball of DTR images (${DTR_IMAGES}) already exists.  If you want to create a new tarball, please remove this file first"
    exit 1
  fi
}

create_net_alias() {
  # run this only on a mac
  if [ "$(uname -s)" = "Darwin" ]
  then
    # check to see if the alias IP is already set
    if ! ifconfig "${NET_IF}" | grep "${ALIAS_IP}" > /dev/null 2>&1
    then
      # create it
      echo "Creating IP alias (requires sudo)..."
      sudo ifconfig "${NET_IF}" alias "${ALIAS_IP}" netmask 255.255.255.255
      echo -e "done.\n"
    else
      # skip creation; already exists
      echo "IP alias (${ALIAS_IP}) already exists"
      echo -e "done.\n"
    fi
  else
    echo "Skipping creation of network IP alias; you're not on a Mac"

    # check to see if the default ALIAS_IP is set
    if [ "${ALIAS_IP}" = "10.1.2.3" ]
    then
      echo "ERROR: ALIAS_IP is not set; set to your host's IP address or installations will fail"
      exit 1
    fi
    echo -e "done.\n"
  fi
}

remove_net_alias() {
  # run this only on a mac
  if [ "$(uname -s)" = "Darwin" ]
  then
    # check to see if the default ALIAS_IP is set
    if [ "${ALIAS_IP}" = "10.1.2.3" ]
    then
      # check to see if the alias IP is already set
      if ifconfig "${NET_IF}" | grep "${ALIAS_IP}" > /dev/null 2>&1
      then
        # remove it
        echo "Removing IP alias (requires sudo)..."
        sudo ifconfig "${NET_IF}" -alias "${ALIAS_IP}" 255.255.255.0
        echo -e "done.\n"
      else
        # skip creation; already exists
        echo "IP alias (${ALIAS_IP}) does not exist; skipping removal..."
        echo -e "done.\n"
      fi
    else
      # skip because custom address provided
      echo "Skipping removal of network IP alias; custom address provided..."
      echo -e "done.\n"
    fi
  else
    echo "Skipping removal of network IP alias; you're not on a Mac..."
    echo -e "done.\n"
  fi
}

recreate_net_alias() {
  echo "Checking to see if network alias is functional..."
  HAPROXY_STATUS="$(curl -m 5 -s -o /dev/null -w "%{http_code}" "http://${ALIAS_IP}/" || true)"
  if [ "${HAPROXY_STATUS}" = "503" ]
  then
    echo -e "Connection test successful; skipping network alias re-creation...\ndone.\n"
  else
    echo "Connection test to HAProxy failed; re-creating network alias..."
    remove_net_alias
    create_net_alias
#    echo -e "done.\n"
  fi
}

check_other_projects() {
  if [ "$(docker ps -a -f label=project -q | wc -l | tr -d ' ')" -ne "0" ]
  then
    # return true (other projects exist)
    echo "1"
  else
    # return false (no other projects exist)
    echo "0"
  fi
}

create_swarm() {
  launch_engines
  init_swarm
}

launch_engines() {
  # create dind network
  echo "Checking for subnet availability..."
  check_subnet
  echo -e "done.\n"

  # create network, if necessary
  create_network

  # get subnet prefix
  DIND_SUBNET_PREFIX="$(docker -H unix:///var/run/docker.sock network inspect --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' "${PROJECT}"_dind | awk -F '/' '{print $1}' | awk -F '.' '{print $1"."$2"."$3"."}')"

  NUM_NODES=$((MANAGERS+WORKERS))

  echo "Creating volumes for docker engines..."
  for ((ENGINE_NUM=1; ENGINE_NUM<=NUM_NODES; ENGINE_NUM++))
  do
    docker -H unix:///var/run/docker.sock volume create \
      --label project="${PROJECT}" \
      --driver local \
      "${PROJECT}"_docker${ENGINE_NUM}

    docker -H unix:///var/run/docker.sock volume create \
      --label project="${PROJECT}" \
      --driver local \
      "${PROJECT}"_docker${ENGINE_NUM}_etc
  done

  docker -H unix:///var/run/docker.sock volume create \
    --label project="${PROJECT}" \
    --driver local \
    "${PROJECT}"_shared
  echo -e "done.\n"

  echo "Launching ${MANAGERS} docker engines for Swarm managers..."
  # launch all managers
  for ((ENGINE_NUM=1; ENGINE_NUM<=MANAGERS; ENGINE_NUM++))
  do
    #shellcheck disable=SC2086
    {
      docker -H unix:///var/run/docker.sock run -d \
        -p 127.0.0.1:100${ENGINE_NUM}:12375 \
        --name "${PROJECT}"_docker${ENGINE_NUM} \
        --hostname "${PROJECT}"_docker${ENGINE_NUM} \
        --label project=${PROJECT} \
        --label role=manager \
        --privileged \
        --net "${PROJECT}"_dind \
        --ip "${DIND_SUBNET_PREFIX}"$((ENGINE_NUM+51)) \
        --restart "${DIND_RESTART}" \
        -v /lib/modules:/lib/modules:ro \
        -v "${PROJECT}"_docker${ENGINE_NUM}_etc:/etc/docker \
        -v "${PROJECT}"_docker${ENGINE_NUM}:/var/lib/docker \
        -v "${PROJECT}"_shared:/data \
        --tmpfs /run \
        mbentley/docker-in-docker:"${DIND_TAG}" \
        dockerd -s overlay2 \
          -H unix:///var/run/docker.sock -H tcp://0.0.0.0:12375 \
          --log-driver json-file --log-opt max-size=50m --log-opt max-file=3 \
          --dns "${DIND_DNS}" ${ENGINE_OPTS}
     }
  done
  echo -e "done.\n"

  echo "Launching ${WORKERS} docker engines for Swarm workers..."
  # launch all managers
  for ((ENGINE_NUM=((MANAGERS+1)); ENGINE_NUM<=((NUM_NODES)); ENGINE_NUM++))
  do
    #shellcheck disable=SC2086
    {
      docker -H unix:///var/run/docker.sock run -d \
        -p 127.0.0.1:100${ENGINE_NUM}:12375 \
        --name "${PROJECT}"_docker${ENGINE_NUM} \
        --hostname "${PROJECT}"_docker${ENGINE_NUM} \
        --label project=${PROJECT} \
        --label role=worker \
        --privileged \
        --net "${PROJECT}"_dind \
        --ip "${DIND_SUBNET_PREFIX}"$((ENGINE_NUM+51)) \
        --restart "${DIND_RESTART}" \
        -v /lib/modules:/lib/modules:ro \
        -v "${PROJECT}"_docker${ENGINE_NUM}_etc:/etc/docker \
        -v "${PROJECT}"_docker${ENGINE_NUM}:/var/lib/docker \
        -v "${PROJECT}"_shared:/data \
        --tmpfs /run \
        mbentley/docker-in-docker:"${DIND_TAG}" \
        dockerd -s overlay2 \
          -H unix:///var/run/docker.sock -H tcp://0.0.0.0:12375 \
          --log-driver json-file --log-opt max-size=50m --log-opt max-file=3 \
          --dns "${DIND_DNS}" ${ENGINE_OPTS}
     }
  done
  echo -e "done.\n"
}

get_container_list() {
  docker ps -a --filter label=project="${PROJECT}" --format '{{.Names}}'
}

get_volume_list() {
  docker volume ls --filter label=project="${PROJECT}" --format '{{.Name}}'
}

get_network_list() {
  docker network ls --filter label=project="${PROJECT}" --format '{{.Name}}'
}

start_containers() {
  # create network, if necessary
  create_network

  CONTAINERS="$(get_container_list)"
  if [ -z "${CONTAINERS}" ]
  then
    echo "No project containers found; skipping..."
  else
    echo "Starting project containers..."
    #shellcheck disable=SC2046
    docker -H unix:///var/run/docker.sock start $(get_container_list) || true
  fi
  echo -e "done.\n"
}

stop_containers() {
  CONTAINERS="$(get_container_list)"
  if [ -z "${CONTAINERS}" ]
  then
    echo "No project containers found; skipping..."
  else
    echo "Stopping project containers; this may take up to 30 seconds..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock stop -t 30 ${CONTAINERS} || true
  fi
  echo -e "done.\n"
}

pause_containers() {
  CONTAINERS="$(get_container_list)"
  if [ -z "${CONTAINERS}" ]
  then
    echo "No project containers found; skipping..."
  else
    echo "Pausing project containers..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock pause ${CONTAINERS} || true
  fi
  echo -e "done.\n"
}

unpause_containers() {
  CONTAINERS="$(get_container_list)"
  if [ -z "${CONTAINERS}" ]
  then
    echo "No project containers found; skipping..."
  else
    echo "Unpausing project containers..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock unpause ${CONTAINERS} || true
  fi
  echo -e "done.\n"
}

recycle_containers() {
  # count the number of existing containers
  get_current_num_engines

  # check to see if the ddc-lb exists
  if [ "$(docker ps -a --filter label=project="${PROJECT}" --format '{{.Names}}' --filter name=ddc-lb)" == "${PROJECT}_ddc-lb" ]
  then
    RECREATE_LB=true
  else
    RECREATE_LB=false
  fi

  stop_containers

  CONTAINERS="$(get_container_list)"
  if [ -z "${CONTAINERS}" ]
  then
    echo "No project containers to remove; skipping..."
  else
  echo "Removing project containers..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock rm ${CONTAINERS}
  fi
  echo -e "done.\n"

  NETWORKS="$(get_network_list)"
  if [ -z "${NETWORKS}" ]
  then
    echo "No project networks to remove; skipping..."
  else
  echo "Removing '${PROJECT}_dind' network..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock network rm ${NETWORKS}
  fi
  echo -e "done.\n"

  launch_engines
  if [ "${RECREATE_LB}" = "true" ]
  then
    launch_haproxy
  fi
}

project_status() {
  echo "Containers for project '${PROJECT}':"
  docker ps -a --filter label=project="${PROJECT}" --format 'table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Names}}\t{{.Labels}}'

  echo -e "\nVolumes for project '${PROJECT}':"
  docker volume ls --filter label=project="${PROJECT}"

  echo -e "\nNetworks for project '${PROJECT}':"
  docker network ls --filter label=project="${PROJECT}"
}

get_current_num_engines() {
  # count the number of existing containers
  MANAGERS="$(docker ps -a --filter label=project="${PROJECT}" --filter label=role=manager --filter name=docker --format '{{.Names}}' | wc -l | tr -d ' ')"
  WORKERS="$(docker ps -a --filter label=project="${PROJECT}" --filter label=role=worker --filter name=docker --format '{{.Names}}' | wc -l | tr -d ' ')"
}

init_swarm() {
  echo "Initializing Swarm on ${PROJECT}_docker1..."
  docker -H tcp://127.0.0.1:1001 swarm init
  echo -e "done.\n"

  # get swarm manager join token
  MANAGER_TOKEN=$(docker -H tcp://127.0.0.1:1001 swarm join-token manager -q)

  # get swarm worker join token
  WORKER_TOKEN=$(docker -H tcp://127.0.0.1:1001 swarm join-token worker -q)

  MANAGER_JOIN_COMMAND="swarm join --token ${MANAGER_TOKEN} $(docker -H unix:///var/run/docker.sock container inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${PROJECT}"_docker1):2377"

  WORKER_JOIN_COMMAND="swarm join --token ${WORKER_TOKEN} $(docker -H unix:///var/run/docker.sock container inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${PROJECT}"_docker1):2377"

  # join managers
  for ((ENGINE_NUM=2; ENGINE_NUM<=MANAGERS; ENGINE_NUM++))
  do
    echo "Joining ${PROJECT}_docker${ENGINE_NUM} to the Swarm..."
    #shellcheck disable=SC2086
    docker -H tcp://127.0.0.1:100${ENGINE_NUM} ${MANAGER_JOIN_COMMAND}
    echo -e "done.\n"
  done

  # join workers
  for ((ENGINE_NUM=((MANAGERS+1)); ENGINE_NUM<=((MANAGERS+WORKERS)); ENGINE_NUM++))
  do
    echo "Joining ${PROJECT}_docker${ENGINE_NUM} to the Swarm..."
    #shellcheck disable=SC2086
    docker -H tcp://127.0.0.1:100${ENGINE_NUM} ${WORKER_JOIN_COMMAND}
    echo -e "done.\n"
  done

  # output node info
  echo -e "Swarm setup complete.\n"
}

connect_engine() {
  ENGINE_NUM="$(echo "${1}" | grep -o '[0-9]\+')"
  echo "# to connect to a given engine, use:"
  #shellcheck disable=SC2016
  echo '# eval "$('"$0"' connect_engine '"${1}"')"'
  echo "export DOCKER_HOST=tcp://127.0.0.1:100${ENGINE_NUM}"
}

install_ucp() {
  echo -e "Preparing cluster for UCP installation...\n"
  # count the number of existing containers
  get_current_num_engines

  create_net_alias
  DOCKER1_IP="$(docker -H unix:///var/run/docker.sock container inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${PROJECT}"_docker1)"

  # load images on managers
  for ((ENGINE_NUM=1; ENGINE_NUM<=MANAGERS; ENGINE_NUM++))
  do
    echo "Loading UCP images for managers on ${PROJECT}_docker${ENGINE_NUM}..."
    #shellcheck disable=SC2086
    docker -H tcp://127.0.0.1:100${ENGINE_NUM} load -i "${UCP_IMAGES}"
    echo -e "done.\n"
  done

  # load images on workers
  for ((ENGINE_NUM=((MANAGERS+1)); ENGINE_NUM<=((MANAGERS+WORKERS)); ENGINE_NUM++))
  do
    echo "Loading UCP images for workers on ${PROJECT}_docker${ENGINE_NUM}..."
    #shellcheck disable=SC2086
    docker -H tcp://127.0.0.1:1001 save "${UCP_REPO}"-agent:"${UCP_VERSION}" | docker -H tcp://127.0.0.1:100${ENGINE_NUM} load || true
    docker -H tcp://127.0.0.1:1001 save "${UCP_REPO}"-hrm:"${UCP_VERSION}" | docker -H tcp://127.0.0.1:100${ENGINE_NUM} load || true
    echo -e "done.\n"
  done

  echo "Installing UCP on ${PROJECT}_docker1..."
  #shellcheck disable=SC2086
  docker -H tcp://127.0.0.1:1001 run -it --rm --name ucp -v /var/run/docker.sock:/var/run/docker.sock "${UCP_REPO}":"${UCP_VERSION}" install ${UCP_OPTIONS} --admin-username admin --admin-password docker123 --host-address "${DOCKER1_IP}" --controller-port 4443 --san "${DOCKER1_IP}" --san "${ALIAS_IP}" --san "$(hostname)" --san "$(hostname -f)" --license "$(cat ${DDC_LICENSE})"
  echo -e "done.\n"

  # add the ALIAS_IP to the SANs engine labels of the managers
  for ((ENGINE_NUM=2; ENGINE_NUM<=MANAGERS; ENGINE_NUM++))
  do
    echo "Adding UCP node label for SANs..."
    docker -H tcp://127.0.0.1:1001 node update --label-add "com.docker.ucp.SANs=$(docker -H tcp://127.0.0.1:1001 node inspect --format '{{(index .Spec.Labels "com.docker.ucp.SANs")}}' "${PROJECT}"_docker${ENGINE_NUM}),${ALIAS_IP}" "${PROJECT}"_docker${ENGINE_NUM}
    echo -e "done.\n"
  done

  # launch haproxy
  launch_haproxy

  # check for jq and then setup HRM
  if hash jq 2>/dev/null
  then
    echo -n "Waiting for UCP to be ready..."
    while [ "$(curl -sk -o /dev/null -w "%{http_code}" "https://${ALIAS_IP}:4443/_ping")" -ne "200" ]
    do
      echo -n "."
      sleep 1
    done
    echo -e "done.\n\nEnabling HRM..."
    AUTH_TOKEN="$(curl -sk -d '{"username":"admin","password":"docker123"}' "https://${ALIAS_IP}:4443/auth/login" | jq -r .auth_token 2>/dev/null)"
    curl -sk -X POST -H "Authorization: Bearer ${AUTH_TOKEN}" --header "Content-Type: application/json" --header "Accept: application/json" -d '{"HTTPPort":80,"HTTPSPort":8443}' "https://${ALIAS_IP}:4443/api/hrm"
    echo -e "done.\n"

    echo "Creating 'demo' user with password 'docker123'..."
    curl -sk -X POST -H "Authorization: Bearer ${AUTH_TOKEN}" --header "Content-Type: application/json" --header "Accept: application/json" -d '{"role":3,"username":"demo","password":"docker123","first_name":"Demo User","admin":true}' "https://${ALIAS_IP}:4443/api/accounts"
    echo -e "done.\n"
  else
    echo -e "Warning: 'jq' not found; you will need to enable HRM and create a demo user manually.\n"
  fi

  echo -e "UCP installation complete.\n"
}

launch_haproxy() {
  # get subnet prefix
  DIND_SUBNET_PREFIX="$(docker -H unix:///var/run/docker.sock network inspect --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' "${PROJECT}"_dind | awk -F '/' '{print $1}' | awk -F '.' '{print $1"."$2"."$3"."}')"

  echo "Launching HAProxy (${PROJECT}_ddc-lb)..."
  docker -H unix:///var/run/docker.sock run -d \
    -p 80:80 \
    -p 443:443 \
    -p 4443:4443 \
    -p 8181:8181 \
    -p 8443:8443 \
    --name "${PROJECT}"_ddc-lb \
    --label project="${PROJECT}" \
    --net "${PROJECT}"_dind \
    --ip "${DIND_SUBNET_PREFIX}"$((MANAGERS+WORKERS+52)) \
    --restart=unless-stopped \
    -e MANAGERS="${MANAGERS}" \
    -e WORKERS="${WORKERS}" \
    -e PROJECT="${PROJECT}" \
    -e DTR_REPLICAS="${DTR_REPLICAS}" \
    mbentley/docker-in-docker:haproxy
  echo -e "done.\n"
}

launch_demo() {
  # launch Jenkins on the first manager for predictable storage
  echo "Creating Jenkins service on '${PROJECT}_docker1'..."
  docker -H tcp://127.0.0.1:1001 service create \
    --detach \
    --replicas 1 \
    --constraint "node.hostname == ${PROJECT}_docker1" \
    --env DTR_URL="${ALIAS_IP}" \
    --env DEMO_MASTER="$(docker -H unix:///var/run/docker.sock inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${PROJECT}"_docker1)" \
    --env DOMAIN_NAME="${DOMAIN_NAME}" \
    --env GITHUB_USERNAME="${GH_USERNAME}" \
    --env GIT_SERVER="http://gogs.${DOMAIN_NAME}" \
    --mount type=volume,source=jenkins-data,destination=/var/lib/jenkins,readonly=false \
    --network ucp-hrm \
    --label "com.docker.ucp.mesh.http.8080=internal_port=8080,external_route=http://jenkins.${DOMAIN_NAME}" \
    --name jenkins \
    dockersolutions/jenkins:latest
  echo -e "done.\n"

  # launch Gogs on the first manager for predictable storage
  echo "Creating Gogs service on '${PROJECT}_docker1'..."
  docker -H tcp://127.0.0.1:1001 service create \
    --detach \
    --replicas 1 \
    --constraint "node.hostname == ${PROJECT}_docker1" \
    --mount type=volume,source=gogs-data,destination=/data,readonly=false \
    --network ucp-hrm \
    --label "com.docker.ucp.mesh.http.3000=internal_port=3000,external_route=http://gogs.${DOMAIN_NAME}" \
    --name gogs \
    mbentley/solutions-gogs:latest
  echo -e "done.\n"
}

install_dtr() {
  echo -e "Preparing cluster for DTR installation...\n"
  # validate the value for # of dtr replicas
  validate_dtr_replicas

  # count the number of existing containers
  get_current_num_engines

  # load images and install dtr to first replica
  ENGINE_NUM=$((MANAGERS+1))
  echo "Loading DTR images on ${PROJECT}_docker${ENGINE_NUM}..."
  docker -H tcp://127.0.0.1:100${ENGINE_NUM} load -i "${DTR_IMAGES}"
  echo -e "done.\n"

  echo "Installing DTR on ${PROJECT}_docker${ENGINE_NUM}..."
  #shellcheck disable=SC2086
  docker -H tcp://127.0.0.1:100${ENGINE_NUM} run -it --rm "${DTR_REPO}":"${DTR_VERSION}" install ${DTR_OPTIONS} --ucp-url https://"${ALIAS_IP}:4443" --ucp-username admin --ucp-password docker123 --ucp-node "${PROJECT}"_docker${ENGINE_NUM} --ucp-ca "$(curl -ks https://"${ALIAS_IP}":4443/ca)" --dtr-external-url "${ALIAS_IP}" --dtr-storage-volume /data --replica-id 0000000000e${ENGINE_NUM} --replica-http-port 8181
  echo -e "done.\n"

  # load images and join additional DTR replicas
  for ((ENGINE_NUM=((MANAGERS+2)); ENGINE_NUM<=((MANAGERS+DTR_REPLICAS)); ENGINE_NUM++))
  do
    echo "Loading DTR images on ${PROJECT}_docker${ENGINE_NUM}..."
    docker -H tcp://127.0.0.1:100${ENGINE_NUM} load -i "${DTR_IMAGES}"
    echo -e "done.\n"

    echo "Joining ${PROJECT}_docker${ENGINE_NUM} as a DTR replica..."
    #shellcheck disable=SC2086
    docker -H tcp://127.0.0.1:100${ENGINE_NUM} run -it --rm "${DTR_REPO}":"${DTR_VERSION}" join ${DTR_OPTIONS} --ucp-url https://"${ALIAS_IP}:4443" --ucp-username admin --ucp-password docker123 --ucp-node "${PROJECT}"_docker${ENGINE_NUM} --ucp-ca "$(curl -ks https://"${ALIAS_IP}":4443/ca)" --existing-replica-id 0000000000e$((MANAGERS+1)) --replica-id 0000000000e${ENGINE_NUM}
    echo -e "done.\n"
  done

  echo -e "DTR installation complete.\n"
}

install_summary_swarm() {
  # Swarm
  echo -e "Swarm mode cluster ready:"
  docker -H tcp://127.0.0.1:1001 node ls
  #shellcheck disable=SC2016
  echo -e "\nTo connect to the engine/Swarm, use:\neval "'"$('"$0"' connect_engine 1)"'
}

install_summary_haproxy() {
  # HAProxy
  echo -e "The HAProxy stats page should now be available at http://${ALIAS_IP}/haproxy?stats"
}

install_summary_ucp() {
  # UCP
  echo -e "UCP should now be available at https://${ALIAS_IP}:4443/"
  echo -e "  Username: admin\tPassword: docker123"
}

install_summary_dtr() {
  # DTR
  echo -e "DTR should now be available at https://${ALIAS_IP}/"
  echo -e "  Username: admin\tPassword: docker123"
}

launch_summary_demo() {
  # Jenkins
  echo -e "Jenkins should now be available at http://jenkins.${DOMAIN_NAME}/ once HRM picks up the configuration"
  echo -e "  Username: demo\tPassword: docker123\n"

  # Gogs
  echo -e "Gogs should now be available at http://gogs.${DOMAIN_NAME}/ once HRM picks up the configuration"
  echo -e "  Username: demo\tPassword: docker123\n"
  echo -e "  Add a git remote using:\n    git remote add gogs http://gogs.${DOMAIN_NAME}/demo/docker-demo.git\n"
  echo -e "  Then you will be able to push using:\n    git push gogs <branch>"
}

destroy_swarm() {
  echo "Warning: This will destroy any containers and data associated with the project ${PROJECT}"
  read -r -p "Would you like to continue? [y/N] " RESPONSE
  case "$RESPONSE" in
    [yY][eE][sS]|[yY])
      # continue
      ;;
    [nN][oO]|[nN])
      echo "Aborting..."
      exit 1
      ;;
    *)
      echo "Invalid input; aborting..."
      exit 1
      ;;
  esac

  CONTAINERS="$(get_container_list)"

  if [ -z "${CONTAINERS}" ]
  then
    echo -e "\nNo project containers to kill; skipping..."
  else
    echo -e "\nKilling project containers..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock kill ${CONTAINERS} || true
  fi
  echo -e "done.\n"

  if [ -z "${CONTAINERS}" ]
  then
    echo "No project containers to remove; skipping..."
  else
    echo "Removing project containers..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock rm ${CONTAINERS}
  fi
  echo -e "done.\n"

  VOLUMES="$(get_volume_list)"
  if [ -z "${VOLUMES}" ]
  then
    echo "No project volumes to remove; skipping..."
  else
    echo "Removing persistent data for docker engines..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock volume rm ${VOLUMES}
  fi
  echo -e "done.\n"

  NETWORKS="$(get_network_list)"
  if [ -z "${NETWORKS}" ]
  then
    echo "No project networks to remove; skipping..."
  else
    echo "Removing '${PROJECT}_dind' network..."
    #shellcheck disable=SC2086
    docker -H unix:///var/run/docker.sock network rm ${NETWORKS}
  fi
  echo -e "done.\n"

  # check to see if other project still exist
  if [ "$(check_other_projects)" -eq "0" ]
  then
    remove_net_alias
  else
    echo -e "Skipping removal of network alias; other projects still exist\ndone."
  fi
}

check_subnet() {
  for i in $(docker -H unix:///var/run/docker.sock network ls -q)
  do
    if [ "$(docker -H unix:///var/run/docker.sock network inspect --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' "${i}")" = "${DIND_SUBNET}" ]
    then
      echo "ERROR: the subnet specified (${DIND_SUBNET}) for the '${PROJECT}_dind' network conflicts with the existing network '$(docker -H unix:///var/run/docker.sock network inspect --format '{{.Name}}' "${i}")'"
      echo "Use DIND_SUBNET to specify a different subnet when launching a new environment"
      exit 1
    fi
  done

  echo "Subnet (${DIND_SUBNET}) is available."
}

create_network() {
  NETWORKS="$(get_network_list)"
  if [ -z "${NETWORKS}" ]
  then
    echo "Creating '${PROJECT}_dind' network with the subnet ${DIND_SUBNET}..."
    docker -H unix:///var/run/docker.sock network create --driver bridge --label project="${PROJECT}" --subnet="${DIND_SUBNET}" "${PROJECT}"_dind
    echo -e "done.\n"
  else
    echo -e "Network '${PROJECT}_dind' already exists; skipping creation...\ndone.\n"
  fi
}

main() {
  case ${1}:${2} in
    launch:all|create_all:*)
      initialize
      ddc_check_license
      ucp_check_tar
      dtr_check_tar
      validate_dtr_replicas
      create_net_alias
      create_swarm
      install_ucp
      install_dtr
      launch_demo
      install_summary_swarm; echo
      install_summary_haproxy; echo
      install_summary_ucp; echo
      install_summary_dtr; echo
      launch_summary_demo
      ;;
    launch:ee|install_ee:*)
      initialize
      ddc_check_license
      ucp_check_tar
      dtr_check_tar
      validate_dtr_replicas
      create_net_alias
      create_swarm
      install_ucp
      install_dtr
      install_summary_swarm; echo
      install_summary_haproxy; echo
      install_summary_ucp; echo
      install_summary_dtr; echo
      ;;
    launch:demo|launch_demo:*)
      initialize
      launch_demo
      launch_summary_demo
      ;;
    launch:ucp|install_ucp:*)
      initialize
      ddc_check_license
      ucp_check_tar
      install_ucp
      install_summary_ucp
      ;;
    launch:dtr|install_dtr:*)
      initialize
      dtr_check_tar
      install_dtr
      install_summary_dtr
      ;;
    launch:swarm|create_swarm:*)
      initialize
      create_swarm
      install_summary_swarm
      ;;
    launch:*|launch:help)
      echo -e "Usage: $0 launch {all|swarm|ee|ucp|dtr|demo|help}"
      if [ "${2}" = "help" ]
      then
        echo -e "\nCommands:"
        echo -e "  all \t\tlaunch a 3 node Swarm mode cluster (1 manager 2 workers), UCP, DTR, Jenkins, and Gogs"
        echo -e "  ee \t\tlaunch a 3 node Swarm mode cluster (1 manager 2 workers), UCP, and DTR"
        echo -e "  swarm \tlaunch 3 node Swarm mode cluster; 1 manager and 2 workers"
        echo -e "  ucp \t\tlaunch UCP on pre-created Swarm"
        echo -e "  dtr \t\tlaunch DTR on the first worker in a pre-created Swarm"
        echo -e "  demo \t\tlaunch Jenkins and Gogs using dockersolutions/jenkins and mbentley/solutions-gogs"
      fi
      exit 1
      ;;
    env:start|start:*)
      initialize
      start_containers
      recreate_net_alias
      ;;
    env:stop)
      initialize
      stop_containers
      ;;
    env:pause)
      initialize
      pause_containers
      ;;
    env:unpause|unpause:*)
      initialize
      unpause_containers
      recreate_net_alias
      ;;
    env:recycle)
      initialize
      recycle_containers
      ;;
    env:destroy|destroy:*|destroy_swarm:*)
      initialize
      destroy_swarm
      ;;
    env:status|status:*)
      initialize
      project_status
      ;;
    env:info|env_info:*)
      initialize
      env_info
      ;;
    env:*)
      echo -e "Usage: $0 env {start|stop|pause|unpause|recycle|destroy|status|info|help}"
      if [ "${2}" = "help" ]
      then
        echo -e "\nCommands:"
	echo -e "  start \tstart ddc-lb, docker1, docker2, and docker3 daemon containers"
	echo -e "  stop \t\tstop ddc-lb, docker1, docker2, and docker3 daemon containers"
	echo -e "  pause \tpause ddc-lb, docker1, docker2, and docker3 daemon containers"
	echo -e "  unpause \tunpause ddc-lb, docker1, docker2, and docker3 daemon containers"
	echo -e "  recycle \tstop, remove, and re-create the docker engines and 'dind' network, keeping persistent data"
	echo -e "  destroy \tremove Swarm, the engines, and all persistent data"
	echo -e "  status \tdisplay environment status"
	echo -e "  info \t\tdisplay enviroment variable overrides currently set"
      fi
      exit 1
      ;;
    create_tar:all)
      initialize
      ucp_create_tar
      dtr_create_tar
      ;;
    create_tar:ucp|ucp_create_tar:*)
      initialize
      ucp_create_tar
      ;;
    create_tar:dtr|dtr_create_tar:*)
      initialize
      dtr_create_tar
      ;;
    create_tar:*)
      echo -e "Usage: $0 create_tar {all|ucp|dtr|help}"
      if [ "${2}" = "help" ]
      then
        echo -e "\nCommands:"
        echo -e "  all \tcreate tarball of the UCP and DTR images"
        echo -e "  ucp \tcreate tarball of the UCP images"
        echo -e "  dtr \tcreate tarball of the DTR images"
      fi
      exit 1
      ;;
    net_alias:create|create_net_alias:*)
      initialize
      create_net_alias
      ;;
    net_alias:remove|remove_net_alias:*)
      initialize
      remove_net_alias
      ;;
    net_alias:recreate|recreate_net_alias:*)
      initialize
      recreate_net_alias
      ;;
    net_alias:*)
      echo -e "Usage: $0 net_alias {create|remove|recreate|help}"
      if [ "${2}" = "help" ]
      then
        echo -e "\nCommands:"
        echo -e "  create \tcreate a network alias used for keeping a persistent IP no matter when you are (only for D4M)"
        echo -e "  remove \tremove network alias (only for D4M)"
        echo -e "  recreate \tre-create network alias (only for D4M)"
      fi
      exit 1
      ;;
    connect_engine:*)
      if [ -z "${2}" ] || [ "${2}" = "help" ]
      then
        #shellcheck disable=SC2016
        echo 'Usage: eval "$('"$0"' connect_engine n)"'
        if [ "${2}" = "help" ]
        then
          echo -e "\nCommands:"
          echo -e "  n \twhere 'n' is the engine number to connect to; sets 'DOCKER*' environment variables"
        fi
        exit 1
      else
        connect_engine "${2}"
      fi
      ;;
    *:*)
      echo "Usage: $0 {launch|env|create_tar|net_alias|connect_engine|help}"
      if [ "${1}" = "help" ]
      then
        echo -e "\nCommands:"
        echo "  $0 launch {all|swarm|ee|ucp|dtr|demo|help}"
        echo "  $0 env {start|stop|pause|unpause|recycle|destroy|status|info|help}"
        echo "  $0 create_tar {all|ucp|dtr|help}"
        echo "  $0 net_alias {create|remove|recreate|help}"
        echo "  $0 connect_engine {n|help}"
      fi
      ;;
  esac
}

main "${@}"
